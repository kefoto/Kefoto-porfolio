<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    canvas {
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <canvas id="physicsCanvas" width="800" height="600"></canvas>
  <script>
    const canvas = document.getElementById('physicsCanvas');
    const ctx = canvas.getContext('2d');

    const balls = [
      { x: 50, y: 50, vx: 0, vy: 0, radius: 20, isDragging: false },
      { x: 150, y: 100, vx: 0, vy: 0, radius: 20, isDragging: false },
      // Add more balls as needed
    ];

    const friction = 0.98;

    function drawBall(ball) {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = 'blue';
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    }

    function updatePhysics() {
      for (const ball of balls) {
        if (ball.isDragging) {
          // Update velocity based on mouse drag
          ball.vx = (ball.x - ball.dragStartX) * 0.1;
          ball.vy = (ball.y - ball.dragStartY) * 0.1;
        } else {
          // Update position based on velocity and apply friction
          ball.vx *= friction;
          ball.vy *= friction;
          ball.x += ball.vx;
          ball.y += ball.vy;

          // Check for collision with canvas borders
          if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
            ball.vx *= -1; // Reverse velocity on collision with horizontal borders
          }
          if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
            ball.vy *= -1; // Reverse velocity on collision with vertical borders
          }

          // Check for collision with other balls
          for (const otherBall of balls) {
            if (ball !== otherBall) {
              const distance = Math.sqrt((ball.x - otherBall.x)**2 + (ball.y - otherBall.y)**2);
              const combinedRadius = ball.radius + otherBall.radius;

              if (distance < combinedRadius) {
                // Collision detected, update velocities for both balls
                const angle = Math.atan2(otherBall.y - ball.y, otherBall.x - ball.x);
                const magnitude1 = Math.sqrt(ball.vx**2 + ball.vy**2);
                const magnitude2 = Math.sqrt(otherBall.vx**2 + otherBall.vy**2);

                const direction1 = Math.atan2(ball.vy, ball.vx);
                const direction2 = Math.atan2(otherBall.vy, otherBall.vx);

                const newVx1 = magnitude1 * Math.cos(direction1 - angle);
                const newVy1 = magnitude1 * Math.sin(direction1 - angle);
                const newVx2 = magnitude2 * Math.cos(direction2 - angle);
                const newVy2 = magnitude2 * Math.sin(direction2 - angle);

                const finalVx1 = ((ball.radius - otherBall.radius) * newVx1 + (2 * otherBall.radius) * newVx2) / (ball.radius + otherBall.radius);
                const finalVx2 = ((2 * ball.radius) * newVx1 + (otherBall.radius - ball.radius) * newVx2) / (ball.radius + otherBall.radius);

                ball.vx = Math.cos(angle) * finalVx1 + Math.cos(angle + Math.PI / 2) * newVy1;
                ball.vy = Math.sin(angle) * finalVx1 + Math.sin(angle + Math.PI / 2) * newVy1;

                otherBall.vx = Math.cos(angle) * finalVx2 + Math.cos(angle + Math.PI / 2) * newVy2;
                otherBall.vy = Math.sin(angle) * finalVx2 + Math.sin(angle + Math.PI / 2) * newVy2;

                // Move balls away from each other to prevent sticking
                const overlap = combinedRadius - distance;
                const moveX = (overlap / 2) * Math.cos(angle);
                const moveY = (overlap / 2) * Math.sin(angle);

                ball.x -= moveX;
                ball.y -= moveY;
                otherBall.x += moveX;
                otherBall.y += moveY;
              }
            }
          }
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (const ball of balls) {
        drawBall(ball);
      }

      requestAnimationFrame(draw);

      // Update physics on each frame
      updatePhysics();
    }

    function onMouseDown(event) {
      const mouseX = event.clientX - canvas.getBoundingClientRect().left;
      const mouseY = event.clientY - canvas.getBoundingClientRect().top;

      // Check if the mouse is over any ball
      for (const ball of balls) {
        const distance = Math.sqrt((mouseX - ball.x)**2 + (mouseY - ball.y)**2);
        if (distance < ball.radius) {
          ball.isDragging = true;
          ball.dragStartX = mouseX;
          ball.dragStartY = mouseY;
          break;
        }
      }
    }

    //wall detection, based on two balls, one ball can not push another one out
    //finding the initial velocity, probaility, record the points for the 0.3 seconds and overwrites
    function onMouseMove(event) {
      for (const ball of balls) {
        if (ball.isDragging) {
          const mouseX = event.clientX - canvas.getBoundingClientRect().left;
          const mouseY = event.clientY - canvas.getBoundingClientRect().top;

          // Update the position of the dragged ball
          ball.x = mouseX;
          ball.y = mouseY;
        }
      }
    }

    function onMouseUp() {
      // Release all dragged balls when the mouse is up
      for (const ball of balls) {
        ball.isDragging = false;
      }
    }

    // Add event listeners
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);

    // Start the animation loop
    draw();
  </script>
</body>
</html>


